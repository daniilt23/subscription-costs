# subscription-costs
## Запуск приложения
добавьте файл .env как .env.example в директорию backend и выполните `make run`, сервер будет доступен на порту 8080
## Команды
- make run (сборка и запуск сервера и бд)
- make swag (изменение сваггера)
- make lint (проверка линтера)
## Описание линтера
- **asciicheck**: Проверка на не ASCI символы в переменных, может быть полезна так как есть русская класиатура и можно написать
'е' и не понять что она не английская
- **copyloopvar**: Будет предлагать убрать избыточные копирования в циклах ведь в go 1.22+ это не нужно
- **cyclop**: Проверяет что каждая функция имеет не более 10 линейно независимых путей (считает условные конструкции которые влияют на сложность) и также сложность всего модуля (package). Больше говорит про читаемость
- **dogsled**: Проверяет количество пустых возвращений из функции (_, _, _, := f()) Если более 1 то стоит пересмотреть логику функции
- **embeddedstructfieldcheck**: Для того чтобы не было встраивания в структуру без явного названия поля
- **err113**: Позволяет проверять правильную работу с ошибками, чтобы не былл прямого сравнения с err == errors.New("some error"). Правильно делать сравнения с кастомными ошибками только через errors.Is
- **errcheck**: с моими настройками check-type-assertions: true check-blank: true verbose: true, будет говорить об ошибках которые игнорируются, то есть какой то метод их возвращает но мы это не проверяем. Также он будет говорить нам о том, когда мы присваиваем пустоту ошибке :num, _ := strconv.Atoi(numStr) // Игнорируется ошибка. verbose нам дает подробный вывод с сигнатурой функции где необработанная ошибка
- **errname**: существует договоренность про наименование ошибок https://go.dev/wiki/Errors#naming. Данный линтер проверяет что название переменной ошибки имеет формат ErrXxx
- **forcetypeassert**: Ищет принудительные присвоения типа без проверки.
```
func f() {
	var a interface{}
	_ = a.(int) // type assertion must be checked
}
```
- **funcorder**: Проверяе что констуркторы написаны только после создания структуры и что сначала идут экспортируемые методы а потом нет.
- **goconst**: Находит повторяющиеся строки, которые можно заменить константой
- **gocritic**: Большой линтер которы предлагает улучшения для читаемости и производительности на основе многих правил и договоренностей (стиль кода, производительность, логические ошибки). В него по дефолту входит много важных линтеров.
- **gocyclo**: Это линтер, который проверяет цикломатическую сложность функций. Он считает непосредственно количество путей выполнения. Удобство для тестируемости
- **godox**: Находит ключевые слова например TODO в комментариях и напоминает о них.
- **gosec**: Находит моменты коде которые могут повлиять на безопасность (любые атаки на сайт)
- **govet**: Проверяет код на наличие подозрительных конструкций, которые могут быть ошибками, но не нарушают синтаксис. Включает в себя огромное количество проверок.
- **importas**: Проверяет согласованность переименований импортов
- **ineffassign**: Ищет неэффективное присвание. Присваивание считается неэфективным если пременная потом не используется или используется но не в зоне видимости
- **interfacebloat**: Проверяет максимальное количество метоов у интерфейсов (максимум 10). Полезно для понимания когда делить интерфейсы на еще более узкие зоны ответственности
- **intrange**: Может быть полезен для упрощения кода ведь он подскажет когда вместо for с нашими значениями можно использовать range
- **lll**: Говорит про максимальную длину строки (для повышения читаемости кода)
- **loggercheck**: Делает проверку на ключ-знаечние в логах. Slog в моем случае. Проверяет что нет пустого значения у ключа
- **misspell**: Проверяет ошибки строковых литералов по UK
- **mnd**: Проверяет на наличие в коде магических чисел (все числа кроме 0 1 и формат с плавающей точкой данных чисел 0.0, 1.0)
Магичечские числа должны выноситься и не использоваться в явном виде
- **musttag**: Все поля структуры которые маршалятся или наоборот, должны иметь struct tag для этого.
- **nestif**: Число вложенных if. Плохо когда много (в простых приложениях лучше не более 3). В этом проекте я поставил 4
- **nilerr**: Проверяет ошибку когда возвращаемое значение nil в обработке ошибки 
```
func f() error {
	err := do()
	if err != nil {
		return nil // miss
	}
```
- **nlreturn**: Требует пустую строку перед оператором return (повышение ясности кода)
- **noinlineerr**: Ошибки и функции заслуживают отдельного внимания поэтому лучше разделять и не писать конструкцию с if err := doSomething(); err != nil {}
- **sqlclosecheck**: Проверяет что все sql.Rows, sql.Stmt, sqlx.NamedStmt, pgx.Query закрылись (то есть был вызван Close())
- **staticcheck**: Важнейший линтер для го, который находит баги, неиспользуемый код, упрощает код, говорит о неправильных проверках
